#include "s21_string.h"
// #include <string.h>
// #include <stdio.h>

/*
* @brief s21_strrchr -  Разбивает строку str на ряд токенов, разделенных delim.

* @Options:
 * @param str - cтрока для поиска в ней лексем. Содержание этой строки будет изменено, 
она разбивается на более мелкие строки (лексемы). Данный параметр может содержать нулевой 
указатель, в этом случае функция продолжает сканирование с того места, где был остановлен 
предыдущий успешный вызов функции.
 * @param delim - cтрока, содержащая разделители. Они могут варьироваться от одного вызова 
к другому вызову функции.
 * @function s21_strspn - вспомогательная функция для определение максимальной длины участка 
 строки, содержащего только указанные символы

* @Return:
Указатель на последнюю найденную лексему в строке.
Возвращается пустой указатель, если нет найденных лексем.

* @Description:
Функция strtok выполняет поиск лексем в строке string. Последовательность вызовов этой функции 
разбивают строку string на лексемы, которые представляют собой последовательности символов, 
разделенных символами разделителями. На первый вызов, функция принимает строку string в качестве 
аргумента, чей первый символ используется в качестве начальной точки для поиска лексем. В 
последующие вызовы, функция ожидает нулевого указателя и использует позицию сразу после окончания 
последней лексемы как новое местонахождение для сканирования. Для определения начала лексемы функция 
сначала определяет символы, не содержащиеся в строке delim, то есть они являются символами разделителями. 
А затем посимвольно проверяет остальную часть строки до первого символа-разделителя, который 
сигнализирует конец лексемы. Этот конечный маркер автоматически заменяется нулевым символом, и лексема 
возвращается функцией. После этого, следующие вызовы функции strtok начинаются с этого нулевого символа.
*/

char *s21_strtok(char *str, const char *delim) {
   static char *address;
   static char *max_pattern;
   static s21_size_t index;
   char *res = s21_NULL;

   if (str != s21_NULL) {
      // присваиваем address первый непустой символ в str, следующий сразу
      // за последним найденным символом, который не входит в delim.
      address = str + s21_strspn(str, delim);
      max_pattern = str + s21_strlen(str);
      index = 0;
   }
   //address[i] - проверяет, является ли символ под индексом i в строке, на которую указывает address,
   //ненулевым. Если это не символ конца строки '\0', условие истинно, и цикл продолжается.
   //count - проверяет есть ли в позиции текущей строки + i, элементы из строки delim
   if (address <= max_pattern) {
      for (int i = 0; address[i]; i++) {
         s21_size_t count = s21_strspn(address + i, delim);
         if (count) {
            for (s21_size_t j = i; j < i + count; j++) {
               address[j] = '\0';
            }
            index =  i + count;
            break;
         }
      }
      res = address;
      address = address + index;
   }
   return res;
}

// int main (void)
// {    
//    // Массив со строкой для поиска
//    char str [24]="test1/test2/test3/test4";
//    // Набор символов, которые должны входить в искомый сегмент
//    char sep [10]="/";
//    // Переменная, в которую будут заноситься начальные адреса частей
//    // строки str

//    char *istr;

//    printf ("Исходная строка: %s\n", str);
//    printf ("Результат разбиения:\n");
//    // Выделение первой части строки
//    istr = s21_strtok (str,sep);

//    // Выделение последующих частей
//    while (istr != NULL)
//    {
//       // Вывод очередной выделенной части
//       printf ("%s\n",istr);
//       // Выделение очередной части строки
//       istr = s21_strtok (NULL,sep);
//    }
//    return 0;
// }

/* 
Отличие между static char *address и char *address заключается в области жизни переменной и способе её инициализации:

char *address: Это обычный указатель на char. Если address инициализируется строковым литералом
(например, char *address = "example";), то строковый литерал фактически копируется в стек или кучу, 
и address указывает на начало этого копированного блока памяти. Важно отметить, что строковые литералы 
обычно размещаются в сегменте данных программы, который является читабельным, но не модифицируемым. 
Попытка изменения содержимого строкового литерала приведёт к неопределённому поведению.

static char *address: Использование ключевого слова static указывает на то, что переменная 
должна иметь статическое хранение. Для указателей это означает, что переменная инициализируется один 
раз при первом обращении к ней и сохраняется между вызовами функций. Если address инициализируется 
строковым литералом, то строковый литерал также копируется в статическую область памяти, и address 
указывает на начало этого блока памяти. Однако важно помнить, что даже если строковый литерал копируется, 
сам литерал остаётся в сегменте данных программы и не может быть изменён.

Основное различие заключается в области жизни переменной и способе её инициализации. 
static char *address гарантирует, что переменная инициализируется один раз и сохраняется 
между вызовами функций, в то время как char *address может требовать дополнительной инициализации 
и может быть изменён в зависимости от контекста использования. */

/*
Когда вы делаете res = address;, вы копируете значение указателя address в res. Это означает, 
что res теперь указывает на тот же блок памяти, на который указывал address. Изменение address 
через address = address + index; не влияет на res, потому что res уже содержит копию старого 
значения address, и оно не обновляется автоматически.

В C, когда вы присваиваете один указатель другому, вы копируете значение указателя, а не саму 
переменную. Это означает, что если вы измените исходный указатель, копия указателя 
(в нашем случае res) не будет автоматически обновляться. Каждый указатель ведет свою собственную 
жизнь и указывает на свой собственный блок памяти.

Таким образом, после первой серии операций:
res указывает на ту же область памяти, что и address.
address указывает на начало строки или массива.
После address = address + index;, address смещается на index элементов вперед от начала строки или массива.
Но res остается неизменным, потому что оно было просто скопировано из address и не обновляется 
автоматически при изменении address.
*/